import { useRef, useCallback } from 'react';
import useSWR from 'swr';
import { withMiddleware, serialize, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, isFunction, UNDEFINED } from 'swr/_internal';
import { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

// We have to several type castings here because `useSWRInfinite` is a special
var INFINITE_PREFIX = '$inf$';
var EMPTY_PROMISE = Promise.resolve();
var getFirstPageKey = function (getKey) {
    return serialize(getKey ? getKey(0, null) : null)[0];
};
var unstable_serialize = function (getKey) {
    return INFINITE_PREFIX + getFirstPageKey(getKey);
};
var infinite = (function (useSWRNext) {
    return function (getKey, fn, config) {
        var didMountRef = useRef(false);
        var dataRef = useRef();
        var cache = config.cache, _a = config.initialSize, initialSize = _a === void 0 ? 1 : _a, _b = config.revalidateAll, revalidateAll = _b === void 0 ? false : _b, _c = config.persistSize, persistSize = _c === void 0 ? false : _c, _d = config.revalidateFirstPage, revalidateFirstPage = _d === void 0 ? true : _d, _e = config.revalidateOnMount, revalidateOnMount = _e === void 0 ? false : _e;
        // The serialized key of the first page. This key will be used to store
        // metadata of this SWR infinite hook.
        var infiniteKey;
        try {
            infiniteKey = getFirstPageKey(getKey);
            if (infiniteKey)
                infiniteKey = INFINITE_PREFIX + infiniteKey;
        }
        catch (err) {
            // Not ready yet.
        }
        var _f = createCacheHelper(cache, infiniteKey), get = _f[0], set = _f[1], subscribeCache = _f[2];
        var getSnapshot = useCallback(function () {
            var size = isUndefined(get().$len) ? initialSize : get().$len;
            return size;
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [cache, infiniteKey, initialSize]);
        useSyncExternalStore(useCallback(function (callback) {
            if (infiniteKey)
                return subscribeCache(infiniteKey, function () {
                    callback();
                });
            return function () { };
        }, 
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [cache, infiniteKey]), getSnapshot, getSnapshot);
        var resolvePageSize = useCallback(function () {
            var cachedPageSize = get().$len;
            return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;
            // `cache` isn't allowed to change during the lifecycle
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [infiniteKey, initialSize]);
        // keep the last page size to restore it with the persistSize option
        var lastPageSizeRef = useRef(resolvePageSize());
        // When the page key changes, we reset the page size if it's not persisted
        useIsomorphicLayoutEffect(function () {
            if (!didMountRef.current) {
                didMountRef.current = true;
                return;
            }
            if (infiniteKey) {
                // If the key has been changed, we keep the current page size if persistSize is enabled
                set({ $len: persistSize ? lastPageSizeRef.current : initialSize });
            }
            // `initialSize` isn't allowed to change during the lifecycle
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [infiniteKey, cache]);
        // Needs to check didMountRef during mounting, not in the fetcher
        var shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;
        // Actual SWR hook to load all pages in one fetcher.
        var swr = useSWRNext(infiniteKey, function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, forceRevalidateAll, originalData, data, pageSize, previousPageData, i, _b, pageKey, pageArg, _c, getSWRCacahe, setSWRCache, pageData, shouldFetchPage;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = get().$ctx || [], forceRevalidateAll = _a[0], originalData = _a[1];
                        data = [];
                        pageSize = resolvePageSize();
                        previousPageData = null;
                        i = 0;
                        _d.label = 1;
                    case 1:
                        if (!(i < pageSize)) return [3 /*break*/, 5];
                        _b = serialize(getKey(i, previousPageData)), pageKey = _b[0], pageArg = _b[1];
                        if (!pageKey) {
                            // `pageKey` is falsy, stop fetching new pages.
                            return [3 /*break*/, 5];
                        }
                        _c = createCacheHelper(cache, pageKey), getSWRCacahe = _c[0], setSWRCache = _c[1];
                        pageData = getSWRCacahe().data;
                        shouldFetchPage = revalidateAll ||
                            forceRevalidateAll ||
                            isUndefined(pageData) ||
                            (revalidateFirstPage && !i && !isUndefined(dataRef.current)) ||
                            shouldRevalidateOnMount ||
                            (originalData &&
                                !isUndefined(originalData[i]) &&
                                !config.compare(originalData[i], pageData));
                        if (!(fn && shouldFetchPage)) return [3 /*break*/, 3];
                        return [4 /*yield*/, fn(pageArg)];
                    case 2:
                        pageData = _d.sent();
                        setSWRCache(__assign(__assign({}, getSWRCacahe()), { data: pageData }));
                        _d.label = 3;
                    case 3:
                        data.push(pageData);
                        previousPageData = pageData;
                        _d.label = 4;
                    case 4:
                        ++i;
                        return [3 /*break*/, 1];
                    case 5:
                        // once we executed the data fetching based on the context, clear the context
                        set({ $ctx: UNDEFINED });
                        // return the data
                        return [2 /*return*/, data];
                }
            });
        }); }, config);
        // update dataRef
        useIsomorphicLayoutEffect(function () {
            dataRef.current = swr.data;
        }, [swr.data]);
        var mutate = useCallback(
        // eslint-disable-next-line func-names
        function (data, opts) {
            // When passing as a boolean, it's explicitly used to disable/enable
            // revalidation.
            var options = typeof opts === 'boolean' ? { revalidate: opts } : opts || {};
            // Default to true.
            var shouldRevalidate = options.revalidate !== false;
            // It is possible that the key is still falsy.
            if (!infiniteKey)
                return EMPTY_PROMISE;
            if (shouldRevalidate) {
                if (!isUndefined(data)) {
                    // We only revalidate the pages that are changed
                    var originalData = dataRef.current;
                    set({ $ctx: [false, originalData] });
                }
                else {
                    // Calling `mutate()`, we revalidate all pages
                    set({ $ctx: [true] });
                }
            }
            return arguments.length
                ? swr.mutate(data, shouldRevalidate)
                : swr.mutate();
        }, 
        // swr.mutate is always the same reference
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [infiniteKey, cache]);
        // Function to load pages data from the cache based on the page size.
        var resolvePagesFromCache = function (pageSize) {
            var _a;
            // return an array of page data
            var data = [];
            var previousPageData = null;
            for (var i = 0; i < pageSize; ++i) {
                var pageKey = serialize(getKey(i, previousPageData))[0];
                // Get the cached page data.
                var pageData = pageKey ? (_a = cache.get(pageKey)) === null || _a === void 0 ? void 0 : _a.data : UNDEFINED;
                // Return the current data if we can't get it from the cache.
                if (isUndefined(pageData))
                    return dataRef.current;
                data.push(pageData);
                previousPageData = pageData;
            }
            // Return the data
            return data;
        };
        // Extend the SWR API
        var setSize = useCallback(function (arg) {
            // It is possible that the key is still falsy.
            if (!infiniteKey)
                return EMPTY_PROMISE;
            var size;
            if (isFunction(arg)) {
                size = arg(resolvePageSize());
            }
            else if (typeof arg == 'number') {
                size = arg;
            }
            if (typeof size != 'number')
                return EMPTY_PROMISE;
            set({ $len: size });
            lastPageSizeRef.current = size;
            return mutate(resolvePagesFromCache(size));
        }, 
        // `cache` and `rerender` isn't allowed to change during the lifecycle
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [infiniteKey, resolvePageSize, mutate, cache]);
        // Use getter functions to avoid unnecessary re-renders caused by triggering
        // all the getters of the returned swr object.
        return {
            size: resolvePageSize(),
            setSize: setSize,
            mutate: mutate,
            get data() {
                return swr.data;
            },
            get error() {
                return swr.error;
            },
            get isValidating() {
                return swr.isValidating;
            },
            get isLoading() {
                return swr.isLoading;
            }
        };
    };
});
var index = withMiddleware(useSWR, infinite);

export { index as default, infinite, unstable_serialize };
